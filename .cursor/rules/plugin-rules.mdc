---
description: 
globs: 
alwaysApply: false
---
# NekroAgent æ’ä»¶å¼€å‘è§„åˆ™

## åŸºç¡€æ¨¡æ¿

```python
from nekro_agent.api import core, message
from nekro_agent.api.plugin import ConfigBase, NekroPlugin, SandboxMethodType
from nekro_agent.api.schemas import AgentCtx
from pydantic import Field

plugin = NekroPlugin(
    name="æ’ä»¶åç§°",
    module_name="æ¨¡å—å",  # å¿…é¡»ä¸å¯å¯¼å…¥çš„æ¨¡å—åä¸€è‡´
    description="æ’ä»¶æè¿°",
    version="0.1.0",
    author="ä½œè€…",
    url="é¡¹ç›®åœ°å€",
    support_adapter=["onebot_v11", "minecraft", "sse"],
)

@plugin.mount_config()
class PluginConfig(ConfigBase):
    SETTING: str = Field(default="é»˜è®¤å€¼", title="æ˜¾ç¤ºå", description="æè¿°")

config = plugin.get_config(PluginConfig)
store = plugin.store  # æ•°æ®å­˜å‚¨

@plugin.mount_sandbox_method(SandboxMethodType.TOOL, "æ–¹æ³•å")
async def method_name(_ctx: AgentCtx, param: str) -> str:
    """æ–¹æ³•æè¿°

    Args:
        param (str): å‚æ•°æè¿°

    Returns:
        str: è¿”å›å€¼æè¿°
    """
    # å®ç°é€»è¾‘
    return "ç»“æœ"

@plugin.mount_cleanup_method()
async def clean_up():
    """æ¸…ç†æ–¹æ³•"""
    pass
```

## æ ¸å¿ƒ API

### æ¶ˆæ¯å‘é€

```python
# å‘é€æ–‡æœ¬
await message.send_text(chat_key, "æ¶ˆæ¯å†…å®¹", _ctx)

# å‘é€å›¾ç‰‡/æ–‡ä»¶
await message.send_image(chat_key, "å›¾ç‰‡è·¯å¾„", _ctx)
await message.send_file(chat_key, "æ–‡ä»¶è·¯å¾„", _ctx)
```

### æ•°æ®å­˜å‚¨

```python
# ä¿å­˜æ•°æ®
await store.set(chat_key="ä¼šè¯ID", store_key="é”®", value="å€¼")

# è¯»å–æ•°æ®
data = await store.get(chat_key="ä¼šè¯ID", store_key="é”®")

# å…¨å±€å­˜å‚¨ï¼ˆä¸æŒ‡å®šchat_keyï¼‰
await store.set(store_key="å…¨å±€é”®", value="å€¼")
```

## SandboxMethodType è¯¦ç»†å¯¹æ¯”

### 1. TOOL - å·¥å…·æ‰§è¡Œå‹

**ç”¨é€”ï¼š** ç›´æ¥æ‰§è¡Œæ“ä½œï¼Œç«‹å³ç”Ÿæ•ˆ
**è¿”å›å€¼ï¼š** æ‰§è¡Œç»“æœæè¿°ï¼ˆstringï¼‰
**AI å¤„ç†ï¼š** AI æ”¶åˆ°ç»“æœåç»§ç»­å¯¹è¯ï¼Œä¸ä¼šé‡æ–°åˆ†æ

```python
@plugin.mount_sandbox_method(SandboxMethodType.TOOL, "å‘é€æ¶ˆæ¯")
async def send_message(_ctx: AgentCtx, chat_key: str, content: str) -> str:
    """å‘é€æ¶ˆæ¯åˆ°èŠå¤©"""
    await message.send_text(chat_key, content, _ctx)
    return "æ¶ˆæ¯å·²å‘é€"  # ç®€å•ç¡®è®¤ä¿¡æ¯
```

### 2. AGENT - åˆ†æä»£ç†å‹

**ç”¨é€”ï¼š** è·å–ä¿¡æ¯ä¾› AI åˆ†æï¼Œä¸ç›´æ¥æ‰§è¡Œæ“ä½œ
**è¿”å›å€¼ï¼š** è¯¦ç»†ä¿¡æ¯å†…å®¹ï¼ˆstringï¼‰
**AI å¤„ç†ï¼š** AI ä¼šåŸºäºè¿”å›å†…å®¹è¿›è¡Œåˆ†æå’Œå†³ç­–

```python
@plugin.mount_sandbox_method(SandboxMethodType.AGENT, "æœç´¢ä¿¡æ¯")
async def search_info(_ctx: AgentCtx, query: str) -> str:
    """æœç´¢ç›¸å…³ä¿¡æ¯"""
    results = await external_search(query)
    # è¿”å›è¯¦ç»†ä¿¡æ¯ä¾›AIåˆ†æ
    return f"æœç´¢ç»“æœï¼š{results}\nè¯·æ ¹æ®ä»¥ä¸Šä¿¡æ¯å›ç­”ç”¨æˆ·é—®é¢˜"
```

### 3. BEHAVIOR - è¡Œä¸ºçŠ¶æ€å‹

**ç”¨é€”ï¼š** ä¿®æ”¹çŠ¶æ€ã€è®°å½•ä¿¡æ¯ï¼Œå½±å“åç»­å¯¹è¯
**è¿”å›å€¼ï¼š** æ“ä½œç¡®è®¤ï¼ˆbool/stringï¼‰
**AI å¤„ç†ï¼š** AI çŸ¥é“çŠ¶æ€å·²æ”¹å˜ï¼Œä¼šè€ƒè™‘æ–°çŠ¶æ€ç»§ç»­å¯¹è¯

```python
@plugin.mount_sandbox_method(SandboxMethodType.BEHAVIOR, "è®¾ç½®å¿ƒæƒ…")
async def set_mood(_ctx: AgentCtx, chat_key: str, mood: str) -> bool:
    """è®¾ç½®å½“å‰å¿ƒæƒ…çŠ¶æ€"""
    await store.set(chat_key=chat_key, store_key="mood", value=mood)
    return True  # çŠ¶æ€å·²æ”¹å˜
```

### 4. MULTIMODAL_AGENT - å¤šæ¨¡æ€ä»£ç†å‹

**ç”¨é€”ï¼š** æä¾›å¤šåª’ä½“å†…å®¹ä¾› AI è§‚å¯Ÿåˆ†æ
**è¿”å›å€¼ï¼š** OpenAI æ¶ˆæ¯æ ¼å¼ï¼ˆDictï¼‰
**AI å¤„ç†ï¼š** AI ä¼š"çœ‹åˆ°"å›¾ç‰‡ç­‰å¤šåª’ä½“å†…å®¹å¹¶è¿›è¡Œåˆ†æ

```python
@plugin.mount_sandbox_method(SandboxMethodType.MULTIMODAL_AGENT, "æ˜¾ç¤ºå›¾ç‰‡")
async def show_image(_ctx: AgentCtx, image_path: str) -> Dict:
    """æ˜¾ç¤ºå›¾ç‰‡ä¾›AIè§‚å¯Ÿ"""
    from nekro_agent.services.agent.creator import ContentSegment, OpenAIChatMessage

    msg = OpenAIChatMessage.create_empty("user")
    msg = msg.add(ContentSegment.text_content("è¿™æ˜¯è¯·æ±‚çš„å›¾ç‰‡ï¼š"))
    msg = msg.add(ContentSegment.image_content_from_path(image_path))
    msg = msg.add(ContentSegment.text_content("è¯·æè¿°ä½ çœ‹åˆ°çš„å†…å®¹"))

    return msg.to_dict()  # è¿”å›æ ‡å‡†OpenAIæ¶ˆæ¯æ ¼å¼
```

### ç±»å‹é€‰æ‹©æŒ‡å—

| ç±»å‹                 | ä½¿ç”¨åœºæ™¯                     | è¿”å›å€¼ç±»å‹          | AI åç»­è¡Œä¸º      |
| -------------------- | ---------------------------- | ------------------- | ---------------- |
| **TOOL**             | å‘é€æ¶ˆæ¯ã€æ–‡ä»¶æ“ä½œã€ç«‹å³æ‰§è¡Œ | `str` ç®€çŸ­ç¡®è®¤      | ç»§ç»­å¯¹è¯         |
| **AGENT**            | æœç´¢ä¿¡æ¯ã€è·å–æ•°æ®ã€å¤–éƒ¨æŸ¥è¯¢ | `str` è¯¦ç»†å†…å®¹      | åˆ†æå†…å®¹åå›å¤   |
| **BEHAVIOR**         | çŠ¶æ€ä¿®æ”¹ã€è®°å½•ä¿¡æ¯ã€è®¾ç½®é…ç½® | `bool/str` æ“ä½œç¡®è®¤ | è€ƒè™‘æ–°çŠ¶æ€ç»§ç»­   |
| **MULTIMODAL_AGENT** | å›¾ç‰‡åˆ†æã€å¤šåª’ä½“å±•ç¤º         | `Dict` OpenAI æ ¼å¼  | è§‚å¯Ÿå¤šåª’ä½“ååˆ†æ |

### å®é™…æ•ˆæœå¯¹æ¯”

```python
# âŒ é”™è¯¯ç”¨æ³•ï¼šç”¨TOOLè¿”å›æœç´¢ç»“æœ
@plugin.mount_sandbox_method(SandboxMethodType.TOOL, "æœç´¢")
async def bad_search(_ctx: AgentCtx, query: str) -> str:
    return "æ‰¾åˆ°äº†å¾ˆå¤šç»“æœ..."  # AIæ— æ³•åˆ©ç”¨å…·ä½“ç»“æœ

# âœ… æ­£ç¡®ç”¨æ³•ï¼šç”¨AGENTè¿”å›è¯¦ç»†æœç´¢ç»“æœ
@plugin.mount_sandbox_method(SandboxMethodType.AGENT, "æœç´¢")
async def good_search(_ctx: AgentCtx, query: str) -> str:
    results = await search_api(query)
    return f"æœç´¢'{query}'çš„ç»“æœï¼š\n{results}\n\nè¯·åŸºäºä»¥ä¸Šä¿¡æ¯å›ç­”"

# âŒ é”™è¯¯ç”¨æ³•ï¼šç”¨AGENTæ‰§è¡Œå‘é€æ“ä½œ
@plugin.mount_sandbox_method(SandboxMethodType.AGENT, "å‘é€æ¶ˆæ¯")
async def bad_send(_ctx: AgentCtx, content: str) -> str:
    await send_message(content)
    return "å·²å‘é€"  # AGENTä¸åº”ç›´æ¥æ‰§è¡Œæ“ä½œ

# âœ… æ­£ç¡®ç”¨æ³•ï¼šç”¨TOOLæ‰§è¡Œå‘é€æ“ä½œ
@plugin.mount_sandbox_method(SandboxMethodType.TOOL, "å‘é€æ¶ˆæ¯")
async def good_send(_ctx: AgentCtx, content: str) -> str:
    await send_message(content)
    return "æ¶ˆæ¯å·²å‘é€"  # TOOLç”¨äºç›´æ¥æ‰§è¡Œ
```

### æ ¸å¿ƒè®¾è®¡ç†å¿µ

**æ‰§è¡Œ vs è§‚å¯Ÿï¼š**

- **TOOL/BEHAVIOR** = AI **æ‰§è¡Œæ“ä½œ**ï¼Œæ”¹å˜å¤–éƒ¨çŠ¶æ€
- **AGENT/MULTIMODAL_AGENT** = AI **è·å–ä¿¡æ¯**ï¼Œç”¨äºå†³ç­–

**è¿”å›å€¼ç”¨é€”ï¼š**

- **TOOL** è¿”å›å€¼ â†’ å‘ŠçŸ¥ AI æ“ä½œç»“æœï¼Œè®© AI ç»§ç»­å¯¹è¯
- **AGENT** è¿”å›å€¼ â†’ æä¾›è¯¦ç»†ä¿¡æ¯ï¼Œè®© AI åˆ†ææ€è€ƒ
- **BEHAVIOR** è¿”å›å€¼ â†’ ç¡®è®¤çŠ¶æ€æ”¹å˜ï¼Œå½±å“ AI åç»­è¡Œä¸º
- **MULTIMODAL_AGENT** è¿”å›å€¼ â†’ è®© AI"çœ‹åˆ°"å¤šåª’ä½“å†…å®¹

**å¸¸è§é”™è¯¯ï¼š**

1. ç”¨ AGENT æ‰§è¡Œæ“ä½œï¼ˆåº”è¯¥ç”¨ TOOLï¼‰
2. ç”¨ TOOL è¿”å›å¤§é‡ä¿¡æ¯ï¼ˆåº”è¯¥ç”¨ AGENTï¼‰
3. MULTIMODAL_AGENT è¿”å› string è€Œä¸æ˜¯ Dict
4. BEHAVIOR ä¸æ›´æ–°çŠ¶æ€åªè¿”å›ä¿¡æ¯ï¼ˆåº”è¯¥ç”¨ AGENTï¼‰

## å®ç”¨æ¨¡å¼

### 1. ç¼“å­˜é¿å…é‡å¤

```python
_CACHE: Dict[str, Any] = {}

async def cached_method(_ctx: AgentCtx, key: str) -> str:
    if key in _CACHE:
        return _CACHE[key]

    result = await expensive_operation(key)
    _CACHE[key] = result
    return result
```

### 2. çŠ¶æ€ç®¡ç†

```python
class PluginState(BaseModel):
    data: Dict[str, Any] = {}
    updated: int = 0

async def get_state(_ctx: AgentCtx) -> PluginState:
    data = await store.get(chat_key=_ctx.chat_key, store_key="state")
    return PluginState.model_validate_json(data) if data else PluginState()

async def save_state(_ctx: AgentCtx, state: PluginState):
    await store.set(chat_key=_ctx.chat_key, store_key="state", value=state.model_dump_json())
```

### 3. å¤–éƒ¨ API è°ƒç”¨

```python
async def api_call(_ctx: AgentCtx, query: str) -> str:
    try:
        async with AsyncClient(proxies=core.config.DEFAULT_PROXY) as client:
            response = await client.get(
                "https://api.example.com/search",
                params={"q": query},
                headers={"Authorization": f"Bearer {config.API_KEY}"},
                timeout=30
            )
            response.raise_for_status()
            return response.json()
    except Exception as e:
        core.logger.exception("APIè°ƒç”¨å¤±è´¥")
        raise Exception(f"è°ƒç”¨å¤±è´¥: {e}")
```

### 4. å¤šæ¨¡æ€æ¶ˆæ¯

```python
from nekro_agent.services.agent.creator import ContentSegment, OpenAIChatMessage

async def multimodal_method(_ctx: AgentCtx, image_path: str) -> Dict:
    msg = OpenAIChatMessage.create_empty("user")
    msg = msg.add(ContentSegment.text_content("æè¿°æ–‡æœ¬"))
    msg = msg.add(ContentSegment.image_content_from_path(image_path))
    return msg.to_dict()
```

### 5. æç¤ºè¯æ³¨å…¥ - æ ¸å¿ƒæœºåˆ¶

**ä½œç”¨ï¼š** æ¯æ¬¡AIå¯¹è¯å¼€å§‹å‰ï¼Œè‡ªåŠ¨å°†æ’ä»¶çŠ¶æ€ä¿¡æ¯æ³¨å…¥åˆ°AIçš„ç³»ç»Ÿæç¤ºè¯ä¸­ï¼Œè®©AIæ„ŸçŸ¥åˆ°å½“å‰çš„ä¸Šä¸‹æ–‡çŠ¶æ€ã€‚

#### åŸºç¡€æ¨¡å¼

```python
@plugin.mount_prompt_inject_method("prompt_name")
async def inject_prompt(_ctx: AgentCtx) -> str:
    """åŸºç¡€æç¤ºè¯æ³¨å…¥"""
    state = await get_state(_ctx)
    if not state.data:
        return ""  # æ— æ•°æ®æ—¶è¿”å›ç©ºå­—ç¬¦ä¸²
    return f"å½“å‰çŠ¶æ€: {state.data}"
```

#### å®ç”¨æ¨¡å¼åˆ†æ

**1. çŠ¶æ€å±•ç¤ºå‹ï¼ˆNoteæ’ä»¶æ¨¡å¼ï¼‰**
```python
@plugin.mount_prompt_inject_method("note_prompt")
async def note_prompt(_ctx: AgentCtx) -> str:
    """æ˜¾ç¤ºç”¨æˆ·å½“å‰çŠ¶æ€å’Œè®°å½•"""
    data = await store.get(chat_key=_ctx.chat_key, store_key="notes")
    notes = NoteData.model_validate_json(data) if data else NoteData()
    
    if not notes.items:
        return "Current Status: No active effects or records"
    
    # æ ¼å¼åŒ–æ˜¾ç¤ºçŠ¶æ€
    status_lines = []
    for title, note in notes.items.items():
        # æ—¶é—´ä¿¡æ¯
        time_elapsed = int(time.time()) - note.start_time
        time_str = f"{time_elapsed//3600}h{(time_elapsed%3600)//60}m" if time_elapsed > 3600 else f"{time_elapsed//60}m"
        
        # æˆªæ–­é•¿æ–‡æœ¬
        desc = note.description[:50] + "..." if len(note.description) > 50 else note.description
        status_lines.append(f"- {title}: {desc} (since {time_str} ago)")
    
    return "Current Status:\n" + "\n".join(status_lines)
```

**2. èµ„æºå±•ç¤ºå‹ï¼ˆEmotionæ’ä»¶æ¨¡å¼ï¼‰**
```python
@plugin.mount_prompt_inject_method("resource_prompt") 
async def resource_prompt(_ctx: AgentCtx) -> str:
    """æ˜¾ç¤ºå¯ç”¨èµ„æºå’Œæœ€è¿‘æ“ä½œ"""
    data = await store.get(chat_key=_ctx.chat_key, store_key="resources")
    resources = ResourceData.model_validate_json(data) if data else ResourceData()
    
    if not resources.recent_items:
        return "Available Resources: None. Use `add_resource` to collect some."
    
    # æ˜¾ç¤ºæœ€è¿‘5ä¸ªèµ„æº
    prompt_parts = ["Recently Available Resources:"]
    for idx, (res_id, resource) in enumerate(resources.recent_items[:5], 1):
        tags = ", ".join(resource.tags[:3]) + ("..." if len(resource.tags) > 3 else "")
        prompt_parts.append(f"{idx}. ID:{res_id} - {resource.name} [Tags: {tags}]")
    
    # æ·»åŠ ä½¿ç”¨æŒ‡å¼•
    prompt_parts.append("Use `search_resource` to find specific items by keywords.")
    
    return "\n".join(prompt_parts)
```

**3. ä»»åŠ¡æé†’å‹ï¼ˆTimeræ’ä»¶æ¨¡å¼ï¼‰**
```python
@plugin.mount_prompt_inject_method("timer_prompt")
async def timer_prompt(_ctx: AgentCtx) -> str:
    """æ˜¾ç¤ºå¾…åŠä»»åŠ¡å’Œå®šæ—¶å™¨"""
    timers = await timer_api.get_active_timers(_ctx.chat_key)
    
    if not timers:
        return "Active Tasks: None"
    
    current_time = int(time.time())
    task_lines = []
    
    for idx, t in enumerate(timers[:3], 1):  # åªæ˜¾ç¤ºå‰3ä¸ª
        remain_seconds = t.trigger_time - current_time
        if remain_seconds <= 0:
            continue
            
        # æ ¼å¼åŒ–å‰©ä½™æ—¶é—´
        hours, remainder = divmod(remain_seconds, 3600)
        minutes = remainder // 60
        time_str = f"{hours}h{minutes}m" if hours > 0 else f"{minutes}m"
        
        # æˆªæ–­æè¿°
        desc = t.description[:40] + "..." if len(t.description) > 40 else t.description
        task_type = "ğŸ”„ Auto" if t.temporary else "â° Scheduled"
        
        task_lines.append(f"{idx}. {task_type} {desc} (in {time_str})")
    
    if not task_lines:
        return "Active Tasks: None"
        
    return "Upcoming Tasks:\n" + "\n".join(task_lines)
```

#### æœ€ä½³å®è·µè§„åˆ™

**1. é•¿åº¦æ§åˆ¶**
```python
# âœ… æ­£ç¡®ï¼šæ§åˆ¶æç¤ºè¯é•¿åº¦
def format_prompt_content(content: str, max_length: int = 200) -> str:
    if len(content) <= max_length:
        return content
    
    # æ™ºèƒ½æˆªæ–­ï¼šä¿ç•™å¼€å¤´å’Œç»“å°¾
    half = max_length // 2 - 10
    return content[:half] + "...[truncated]..." + content[-half:]

@plugin.mount_prompt_inject_method("controlled_prompt")
async def controlled_prompt(_ctx: AgentCtx) -> str:
    full_content = await get_full_state_info(_ctx)
    return format_prompt_content(full_content, max_length=300)
```

**2. æ¡ä»¶è¿”å›**
```python
# âœ… æ­£ç¡®ï¼šæœ‰æ¡ä»¶åœ°è¿”å›æç¤ºè¯
@plugin.mount_prompt_inject_method("conditional_prompt")
async def conditional_prompt(_ctx: AgentCtx) -> str:
    state = await get_state(_ctx)
    
    # æ— çŠ¶æ€æ—¶è¿”å›ç©ºå­—ç¬¦ä¸²
    if not state or not state.has_active_data():
        return ""
    
    # åªåœ¨ç›¸å…³åœºæ™¯ä¸‹æ³¨å…¥
    if not state.should_show_in_prompt():
        return ""
    
    return state.render_prompt()
```

**3. é”™è¯¯å¤„ç†**
```python
# âœ… æ­£ç¡®ï¼šå®‰å…¨çš„æç¤ºè¯æ³¨å…¥
@plugin.mount_prompt_inject_method("safe_prompt")
async def safe_prompt(_ctx: AgentCtx) -> str:
    try:
        state = await get_state(_ctx)
        if not state:
            return ""
        
        return state.render_safe_prompt()
        
    except Exception as e:
        # æç¤ºè¯æ³¨å…¥å¤±è´¥ä¸åº”å½±å“å¯¹è¯
        core.logger.warning(f"æç¤ºè¯æ³¨å…¥å¤±è´¥: {e}")
        return ""  # é™é»˜å¤±è´¥ï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²
```

#### ä½¿ç”¨åœºæ™¯å¯¹æ¯”

| åœºæ™¯ | å…¸å‹ç”¨é€” | è¿”å›å†…å®¹ | æ›´æ–°é¢‘ç‡ |
|------|----------|----------|----------|
| **çŠ¶æ€å±•ç¤º** | è§’è‰²çŠ¶æ€ã€æ•ˆæœè®°å½• | å½“å‰ç”Ÿæ•ˆçš„çŠ¶æ€ä¿¡æ¯ | çŠ¶æ€å˜åŒ–æ—¶ |
| **èµ„æºå±•ç¤º** | å¯ç”¨å·¥å…·ã€æ”¶è—å†…å®¹ | æœ€è¿‘æ·»åŠ çš„èµ„æºåˆ—è¡¨ | æ–°å¢èµ„æºæ—¶ |
| **ä»»åŠ¡æé†’** | å®šæ—¶å™¨ã€å¾…åŠäº‹é¡¹ | å³å°†è§¦å‘çš„ä»»åŠ¡ | å®æ—¶è®¡ç®— |
| **ä¸Šä¸‹æ–‡æ„ŸçŸ¥** | å¯¹è¯åœºæ™¯ã€ç”¨æˆ·æƒ…ç»ª | åŠ¨æ€è°ƒæ•´çš„è¡Œä¸ºæŒ‡å¼• | æ ¹æ®å¯¹è¯å˜åŒ– |

#### å¸¸è§é”™è¯¯

```python
# âŒ é”™è¯¯ï¼šè¿”å›è¿‡é•¿å†…å®¹
async def bad_prompt(_ctx: AgentCtx) -> str:
    return await get_all_detailed_info(_ctx)  # å¯èƒ½è¿”å›å‡ åƒå­—

# âŒ é”™è¯¯ï¼šæ€»æ˜¯è¿”å›å›ºå®šå†…å®¹  
async def bad_prompt(_ctx: AgentCtx) -> str:
    return "æ’ä»¶å·²å¯ç”¨"  # æ— æ„ä¹‰çš„å›ºå®šæ–‡æœ¬

# âŒ é”™è¯¯ï¼šå¿½ç•¥å¼‚å¸¸
async def bad_prompt(_ctx: AgentCtx) -> str:
    state = await get_state(_ctx)  # å¯èƒ½æŠ›å¼‚å¸¸
    return state.info  # æœªå¤„ç†å¼‚å¸¸

# âœ… æ­£ç¡®ï¼šç²¾ç®€ã€åŠ¨æ€ã€å®‰å…¨
async def good_prompt(_ctx: AgentCtx) -> str:
    try:
        state = await get_state(_ctx)
        if not state or not state.should_display():
            return ""
        return state.get_summary(max_length=150)
    except Exception:
        return ""
```

## é”™è¯¯å¤„ç†

```python
async def robust_method(_ctx: AgentCtx, param: str) -> str:
    # å‚æ•°éªŒè¯
    if not param or not param.strip():
        raise ValueError("å‚æ•°ä¸èƒ½ä¸ºç©º")

    try:
        result = await operation(param)
        return result
    except ValueError as e:
        raise ValueError(f"å‚æ•°é”™è¯¯: {e}")
    except Exception as e:
        core.logger.exception("æ“ä½œå¤±è´¥")
        raise Exception(f"æ‰§è¡Œå¤±è´¥: {e}")
```

## é…ç½®é€‰é¡¹

```python
@plugin.mount_config()
class Config(ConfigBase):
    # åŸºç¡€ç±»å‹
    TEXT_SETTING: str = Field(default="é»˜è®¤", title="æ–‡æœ¬è®¾ç½®")
    NUMBER_SETTING: int = Field(default=10, title="æ•°å­—è®¾ç½®")
    BOOL_SETTING: bool = Field(default=True, title="å¸ƒå°”è®¾ç½®")

    # ç‰¹æ®Šæ ‡è®°
    SECRET_KEY: str = Field(
        default="",
        title="å¯†é’¥",
        json_schema_extra={"is_secret": True}  # æ•æ„Ÿä¿¡æ¯
    )

    MODEL_GROUP: str = Field(
        default="default-chat",
        title="æ¨¡å‹ç»„",
        json_schema_extra={
            "ref_model_groups": True,  # å¼•ç”¨æ¨¡å‹ç»„
            "model_type": "chat"       # æ¨¡å‹ç±»å‹
        }
    )
```

## å¸¸è§é—®é¢˜

### æ–‡ä»¶è·¯å¾„è½¬æ¢

```python
from nekro_agent.tools.path_convertor import convert_to_host_path

# å®¹å™¨è·¯å¾„è½¬ä¸»æœºè·¯å¾„
host_path = convert_to_host_path(Path(container_path), _ctx.chat_key)
```

### é˜²é‡å¤è°ƒç”¨

```python
import time

_last_call = {}

async def throttled_method(_ctx: AgentCtx, key: str) -> str:
    now = time.time()
    if key in _last_call and now - _last_call[key] < 10:  # 10ç§’å†…ä¸é‡å¤
        return "è¯·ç¨åå†è¯•"

    _last_call[key] = now
    return await do_work(key)
```

### å¤šé€‚é…å™¨æ”¯æŒ

```python
@plugin.mount_collect_methods()
async def collect_available_methods(_ctx: AgentCtx) -> List:
    if _ctx.adapter_key == "minecraft":
        return [text_only_method]
    elif _ctx.adapter_key == "onebot_v11":
        return [text_method, image_method]
    return [text_method]
```

## å¼€å‘æ£€æŸ¥

- [ ] ç¡®ä¿åº”ç”¨æç¤ºè¯å‹å¥½
- [ ] `_ctx: AgentCtx` å‚æ•°åœ¨ç¬¬ä¸€ä½
- [ ] æ–‡æ¡£å­—ç¬¦ä¸²ä¸æš´éœ² `_ctx`
- [ ] é€‰æ‹©æ­£ç¡®çš„ SandboxMethodType
- [ ] å¼‚å¸¸å¤„ç†å®Œæ•´
- [ ] å®ç°æ¸…ç†æ–¹æ³•
- [ ] å‚æ•°éªŒè¯
- [ ] ä½¿ç”¨å¼‚æ­¥æ“ä½œ
- [ ] æç¤ºè¯æ³¨å…¥é•¿åº¦æ§åˆ¶ï¼ˆ<300å­—ç¬¦ï¼‰
- [ ] æç¤ºè¯æ³¨å…¥é”™è¯¯å¤„ç†å®‰å…¨
- [ ] æ— çŠ¶æ€æ—¶è¿”å›ç©ºå­—ç¬¦ä¸²
